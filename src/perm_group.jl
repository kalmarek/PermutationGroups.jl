"""
    PermGroup(gens...)
Permutation group generated by `gens`.

`PermGroup`s are by definition sub-groups of the full symmetric group. Order
and stabilizer chain are computed (and cached) _when needed_.
"""
mutable struct PermGroup{P<:AbstractPermutation,T<:AbstractTransversal} <:
                AbstractPermutationGroup
    __gens_raw::Vector{P}
    @atomic stabchain::StabilizerChain{P,T}
    @atomic order::BigInt

    function PermGroup(
        T::Type{<:AbstractTransversal},
        gens::AbstractVector{<:AbstractPermutation},
    )
        @assert !isempty(gens) "groups need to have at least one generator"
        gens_raw = [AP.perm(s) for s in gens]
        Tr = __schreier_sims_transversal(T, eltype(gens_raw))
        return new{eltype(gens_raw),Tr}(gens_raw)
    end
end

function PermGroup(gens::AbstractVector{<:AbstractPermutation})
    return PermGroup(Transversal, gens)
end

function PermGroup(gens::Vararg{P,N}) where {P<:AbstractPermutation,N}
    return PermGroup(collect(gens))
end

__gens_raw(G::PermGroup) = G.__gens_raw

struct Permutation{P,G<:PermGroup} <: AbstractPermutation
    perm::P
    parent::G
end

# AbstractPermutation interface
AP.degree(p::Permutation) = AP.degree(p.perm)
Base.:^(n::Integer, p::Permutation) = n^p.perm

AP.perm(p::Permutation) = AP.perm(p.perm)
AP.inttype(::Type{<:Permutation{P}}) where {P} = AP.inttype(P)

Base.one(p::Permutation) = Permutation(one(p.perm), parent(p))
Base.copy(σ::Permutation) = Permutation(σ.perm, parent(σ))

function Base.:*(p::Permutation, qs::Permutation...)
    G = parent(p)
    r = *(AP.perm(p), map(AP.perm, qs)...)
    if !all(parent(q) === G for q in qs)
        @assert all(AP.perm(q) in G for q in qs)
    end
    return Permutation(r, G)
end

function Base.:*(p::Permutation, qs::AbstractPermutation...)
    G = parent(p)
    r = *(AP.perm(p), map(AP.perm, qs)...)
    @assert r in G
    return Permutation(r, G)
end

function Base.:^(σ::Permutation{P}, τ::AbstractPermutation) where {P}
    deg = max(AP.degree(σ), AP.degree(τ))
    img = Vector{AP.inttype(σ)}(undef, deg)
    for i in Base.OneTo(deg)
        img[i^τ] = (i^σ)^τ
    end

    res = P(img; check = false)
    @assert res in parent(σ)
    return Permutation(res, parent(σ))
end

function AP.power_by_cycles(σ::Permutation, n::Integer)
    return Permutation(AP.power_by_cycles(AP.perm(σ), n), parent(σ))
end

# misc
"""
    StabilizerChain(G::PermGroup)
Construct the stabilizer chain for group `G`.

The first call on a particular group `G` will construct the chain from `gens(G)`
and complete it by the deterministic Schreier-Sims algorithm.
The subsequent calls just return the cached data structure.
"""

function StabilizerChain(G::PermGroup{P,T}) where {P,T}
    if !isdefined(G, :stabchain, :sequentially_consistent)
        stabchain = schreier_sims(T, __gens_raw(G))
        # this may take some time, so let's check again
        if !isdefined(G, :stabchain, :sequentially_consistent)
            @atomic G.stabchain = stabchain
        end
    end
    return G.stabchain
end

basis(G::AbstractPermutationGroup) = basis(StabilizerChain(G))

# iteration protocol for PermGroups

Base.eltype(::Type{GT}) where {P,GT<:PermGroup{P}} = Permutation{P,GT}

function Base.iterate(G::PermGroup)
    lfs = leafs(StabilizerChain(G))
    σ, st = iterate(lfs)
    return Permutation(σ, G), (lfs, st)
end

function Base.iterate(G::PermGroup, state)
    lfs, st = state
    next = iterate(lfs, st)
    isnothing(next) && return nothing
    σ, st = next
    return Permutation(σ, G), (lfs, st)
end
