"""
    PermGroup(gens...)
Permutation group generated by `gens`.

`PermGroup`s are by definition sub-groups of the full symmetric group. Order
and stabilizer chain are computed (and cached) _when needed_.
"""
@static if VERSION < v"1.7"
    mutable struct PermGroup{P<:AbstractPermutation,T<:AbstractTransversal} <:
                   AbstractPermutationGroup
        __gens_raw::Vector{P}
        stabchain::StabilizerChain{P,T}
        order::BigInt

        function PermGroup(
            T::Type{<:AbstractTransversal},
            gens::AbstractVector{<:AbstractPermutation},
        )
            return new{eltype(gens),T}([Perms.perm(s) for s in gens])
        end
    end
else
    mutable struct PermGroup{P<:AbstractPermutation,T<:AbstractTransversal} <:
                   AbstractPermutationGroup
        __gens_raw::Vector{P}
        @atomic stabchain::StabilizerChain{P,T}
        @atomic order::BigInt

        function PermGroup(
            T::Type{<:AbstractTransversal},
            gens::AbstractVector{<:AbstractPermutation},
        )
            return new{eltype(gens),T}([Perms.perm(s) for s in gens])
        end
    end
end

for T in (:Transversal, :SchreierTransversal)
    @eval function PermGroup(
        ::Type{$T},
        gens::AbstractVector{<:AbstractPermutation},
    )
        return PermGroup($T(eltype(gens)), gens)
    end
end

function PermGroup(gens::AbstractVector{<:AbstractPermutation})
    return PermGroup(Transversal, gens)
end

PermGroup(gens::Vararg{P,N}) where {P,N} = PermGroup(collect(gens))

struct Permutation{P,G<:PermGroup} <: AbstractPermutation
    perm::P
    parent::G
end

__gens_raw(G::PermGroup) = G.__gens_raw

Perms.perm(p::Permutation) = Perms.perm(p.perm)

# Perms.Perm interface
Perms.inttype(::Type{<:Permutation{P}}) where {P} = Perms.inttype(P)
Perms.degree(p::Permutation) = Perms.degree(p.perm)
Base.:^(n::Integer, p::Permutation) = n^p.perm
Base.one(p::Permutation) = Permutation(one(p.perm), parent(p))

function Base.:*(p::Permutation, qs::Permutation...)
    G = parent(p)
    @assert all(parent(q) === G for q in qs)
    r = *(Perms.perm(p), map(Perms.perm, qs)...)
    # @assert r in G
    return Permutation(r, G)
end

function Base.:*(p::Permutation, qs::AbstractPermutation...)
    G = parent(p)
    r = *(Perms.perm(p), map(Perms.perm, qs)...)
    @assert r in G
    return Permutation(r, G)
end

function Base.conj(σ::Permutation{P}, τ::AbstractPermutation) where {P}
    deg = max(degree(σ), degree(τ))
    img = Vector{Perms.inttype(Perms.perm(σ))}(undef, deg)
    for i in Base.OneTo(deg)
        img[i^τ] = (i^σ)^τ
    end

    res = P(img, false)
    @assert res in parent(σ)
    return Permutation(res, parent(σ))
end

# misc
"""
    StabilizerChain(G::PermGroup)
Construct the stabilizer chain for group `G`.

The first call on a particular group `G` will construct the chain from `gens(G)`
and complete it by the deterministic Schreier-Sims algorithm.
The subsequent calls just return the cached data structure.
"""
@static if VERSION < v"1.7"
    function StabilizerChain(G::PermGroup{P,T}) where {P,T}
        if !isdefined(G, :stabchain)
            stabchain = schreier_sims(T, __gens_raw(G))
            # this may take some time, so let's check again
            if !isdefined(G, :stabchain)
                G.stabchain = stabchain
            end
        end
        return G.stabchain
    end
else
    function StabilizerChain(G::PermGroup{P,T}) where {P,T}
        if !isdefined(G, :stabchain, :sequentially_consistent)
            stabchain = schreier_sims(T, __gens_raw(G))
            # this may take some time, so let's check again
            if !isdefined(G, :stabchain, :sequentially_consistent)
                @atomic G.stabchain = stabchain
            end
        end
        return G.stabchain
    end
end

basis(G::AbstractPermutationGroup) = basis(StabilizerChain(G))

# iteration protocol for PermGroups

Base.eltype(::Type{GT}) where {P,GT<:PermGroup{P}} = Permutation{P,GT}

function Base.iterate(G::PermGroup)
    lfs = leafs(StabilizerChain(G))
    σ, st = iterate(lfs)
    return Permutation(σ, G), (lfs, st)
end

function Base.iterate(G::PermGroup, state)
    lfs, st = state
    next = iterate(lfs, st)
    isnothing(next) && return nothing
    σ, st = next
    return Permutation(σ, G), (lfs, st)
end
