###############################################################################
# StabilizerChain and Scheier-Sims algorithm
###############################################################################

function sift(g::AbstractPerm, base::Vector{<:Integer}, transversals::AbstractVector{Orb}) where {Orb<:AbstractOrbit}
    h = g

    for (i, Δ) in enumerate(transversals)
        β = base[i]^h
        β ∈ Δ || return h, i
        # uᵦ = Δ[β]
        h = h*getinv(Δ, β) # assuming: Δ=orbits[i] is based on base[i]
    end
    return h, length(transversals)+1
end

@doc doc"""
    initial_bsgs(gens::AbstractVector{<:AbstractPerm}[, B::=Int[]])
Compute the initial base and strong generating set from generators `gens` and initial base `B`.

It will remove duplicates and may reorder points in `B`. If the initial base
is not provided the first point moved by each of `gens` will be taken.
"""
function initial_bsgs(gens::AbstractVector{<:AbstractPerm}, B=Int[])

	T = eltype(eltype(gens))

	B = if isempty(B)
        B = unique!(T[firstmoved(g) for g in gens if firstmoved(g) isa Integer])
        sort!(B)
	else
		filter(b -> !all(fixes.(gens, b)), B)
    end

	isempty(B) && return T[1], [[one(first(gens))]]

    S = [[g for g in gens if firstmoved(g) ≥ b] for b in B]

    return B, S
end

function Base.show(io::IO, ::MIME"text/plain", sc::StabilizerChain)
    println(io, "StabilizerChain of size $(order(sc)) with base $(base(sc))")
    for i in 1:length(sc)
        b, S, Δ = sc[i]
        println(io, "Orbit:\t", collect(Δ))
        println(io, "Stabilized by:")
		Base.print_array(io, S)
		println(io, "")
    end
end

Base.show(io::IO, sc::StabilizerChain) =
	print(io, "StabilizerChain of size $(order(sc)) with base $(base(sc))")

@doc doc"""
    StabilizerChain(G::PermGroup)
Construct the stabilizer chain for group `G`.

The first call on a particular group `G` will construct the chain from `gens(G)`
and complete by the deterministic Schreier-Sims algorithm.
The subsequent calls just return the cached copy.

!!! Warning !!! It is users responsibility to ensure that the cached copy is
completed by call to `schreier_sims!` if the `base` or `gens` are changed
manually after groups creation.
"""
function StabilizerChain(G::PermGroup)
    if !(isdefined(G, :stabchain))
        G.stabchain = schreier_sims!(StabilizerChain(gens(G)))
    end
    return G.stabchain
end

@doc doc"""
    StabilizerChain(gens, B)
Construct the initial `StabilizerChain` object from generators `gens` and initial basis `B`.

The returned `StabilizerChain` is **not** completed. Use `schreier_sims!` for completion.
"""
function StabilizerChain(gens::AbstractVector{Perm{I}}, B::AbstractVector{I}=I[]) where I
    B, S = initial_bsgs(gens, B)
    T = [Schreier(gs, pt) for (pt, gs) in zip(B, S)]
    return StabilizerChain(B, S, T)
end
StabilizerChain(gens::AbstractVector{<:AbstractPerm}) = StabilizerChain(perm.(gens))

@doc doc"""
    sgs(sc::StabilizerChain)
Return strong generating set of the group defined by `sc`, i.e. unique generators
for all of the stabilizers in `sc`.
"""
sgs(sc::StabilizerChain) = unique!(vcat(sc.sgs...))

@doc doc"""
    base(sc::StabilizerChain)
Return the base of the stabilizer chain.
"""
@inline base(sc::StabilizerChain) = sc.base

@inline Base.length(sc::StabilizerChain) = length(sc.base)
@inline Base.getindex(sc::StabilizerChain, n) = sc.base[n], sc.sgs[n], sc.transversals[n]

@doc doc"""
    sift(g::Perm, sc::StabilizerChain) → (h, depth)::Tuple{Perm, Int}
Sift the element `g` through the StabilizerChain.

The returned tuple consists of
 * `h::Perm` → the residual of `g` after dividing by the stabilizers of `sc`
 * `depth` → the depth where the sifting procedure has stopped.

If `depth` is less than or equal to depth of `sc` (i.e. `length(sc)`) then `g`
does not belong to the group generated by `sc`.
If `h == length(sc) + 1` and `h` is the identity element then `g` belons to
the group generated by `sc`.
"""
sift(g::AbstractPerm, sc::StabilizerChain) = sift(g, sc.base, sc.transversals)

@doc doc"""
    push!(sc::StabilizerChain{I}, pt::I} where I
Extend the chain by pushing point `pt` to the base of `sc`.

The corresponding `sgs` and `transversals` fields are also extended
(to match `base` in length), but are **not initialized**.
"""
function Base.push!(sc::StabilizerChain{I}, pt::I) where I
    push!(sc.base, pt)
    push!(sc.sgs, Perm{I}[])
    resize!(sc.transversals, length(sc.transversals)+1)
    return pt
end

@doc doc"""
    recompute_transversal!(sc::StabilizerChain, depth)
Recompute the Schreier tree of `sc` at depth `depth`.

This allows shallower Schreier trees after `pushing` generators to `sc`.
"""
@inline function recompute_transversal!(sc::StabilizerChain, depth)
    sc.transversals[depth] = Schreier(sc.sgs[depth], sc.base[depth])
end

@doc doc"""
    push!(sc::StabilizerChain, h, depth[, recompute=false])
Add generator `h` to `sc` at depth `depth`.

If `recompute=true`, then the Schreier tree will be recomputed (as it may become shallower).
"""
function Base.push!(sc::StabilizerChain{I, GEl}, h::GEl, depth::Int; recompute::Bool=false) where {I, GEl}
    push!(sc.sgs[depth], h)
    recompute && recompute_transversal!(sc, depth)
    return h
end

@doc doc"""
    order(sc::StabilizerChain) → BigInt
Compute the order of the group generated by `sc`.
"""
GroupsCore.order(sc::StabilizerChain) = order(BigInt, sc)
GroupsCore.order(::Type{T}, sc::StabilizerChain) where T =
	mapreduce(length, *, sc.transversals, init=one(T))

@doc doc"""
	transversals(sc::StabilizerChain)
Return the transversals (as a Vector) from stabilizer chain `sc`.
"""
transversals(sc::StabilizerChain) = sc.transversals
