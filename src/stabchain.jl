"""
    StabilizerChain{P<:AbstractPermutation}
A structure to represent (partial) stabilizer chain.

If `G` is a group generated by a set of permutations, then for a choice of basis
> `β = (β₀, β₁, …, βₙ)`

we obtain a sequence of groups
> `G = G₀ ≥ G₁ ≥ … ≥ G₀ = {1}`.

where `Gₖ₊₁ ≤ Stab_{Gₖ}(βₖ)`. A `stbch::PointStabilizer` typically represent `Gₖ`
in the following sense:
 * `gens(stbch)` is the generating set for `Gₖ`,
 * `point(stbch)` returns `βₖ`
 * `transversal(stbch)` is the transversal of `βₖ` w.r.t. to `gens(pts)` and
 * `stabilizer(stbch)::PointStabilizer` represents `Gₖ₊₁`.

By convention `stbch` represents `G₀` (i.e. the trivial group) if
`istrivial(stbch) == true`.
"""
mutable struct StabilizerChain{P<:AbstractPermutation,T<:AbstractTransversal}
    gens::Vector{P}
    transversal::T
    stabilizer::StabilizerChain{P,T}

    StabilizerChain{P,T}() where {P,T} = new{P,T}(P[])
end

GroupsCore.gens(pts::StabilizerChain) = pts.gens
stabilizer(pts::StabilizerChain) = pts.stabilizer
transversal(pts::StabilizerChain) = pts.transversal
orbit(pts::StabilizerChain) = orbit(transversal(pts))

point(pts::StabilizerChain) = first(transversal(pts))
GroupsCore.istrivial(pts::StabilizerChain) = isempty(gens(pts))

GroupsCore.order(stabch::StabilizerChain) = order(BigInt, stabch)
function GroupsCore.order(::Type{I}, stabch::StabilizerChain) where {I}
    istrivial(stabch) && return one(I)
    return convert(I, length(transversal(stabch))) *
           order(I, stabilizer(stabch))
end

# iteration over layers of StabilizerChain
function Base.iterate(stabch::StabilizerChain, state = stabch)
    istrivial(state) && return nothing
    return state, stabilizer(state)
end

Base.length(stabch::StabilizerChain) = depth(stabch)
Base.eltype(::Type{SC}) where {SC<:StabilizerChain} = SC

"""
    recompute_transversal!(sc::StabilizerChain)
Recompute the Schreier tree of `sc`.

This allows shallower Schreier trees after new generators were added to `sc`.
"""
function recompute_transversal!(sc::StabilizerChain{P,T}) where {P,T}
    return sc.transversal = T(first(transversal(sc)), gens(sc))
end

function depth(stabch::StabilizerChain)
    depth = 0
    while !istrivial(stabch)
        depth += 1
        stabch = stabilizer(stabch)
    end
    return depth
end

basis(stabch::StabilizerChain) = [first(transversal(sc)) for sc in stabch]

function __print(io::IO, mime::MIME"text/plain", sc::StabilizerChain, indent)
    print(io, indent)
    println(io, "Generators: ", gens(sc))
    print(io, indent)
    show(io, mime, orbit(sc))
    return
end

function Base.show(io::IO, mime::MIME"text/plain", sc::StabilizerChain)
    show(io, sc)
    print(io, ':')
    idnt = 2
    for (idx, layer) in enumerate(sc)
        println(io)
        __print(io, mime, layer, ' '^idnt * "├─ ")
        if idx < length(sc)
            print(io, "\n", ' '^idnt * "└─┬─ Stabilized by:")
            idnt += 2
        else
            print(io, "\n", ' '^idnt * "└─ Stabilized by: (trivial group)")
        end
    end
end

function Base.show(io::IO, sc::StabilizerChain)
    return print(
        io,
        "Stabilizer chain of size $(order(sc)) with base $(convert.(Int, basis(sc)))",
    )
end

struct Leafs{T}
    iters::Vector{T}
    total_len::Int
end

depth(lfs::Leafs) = length(lfs.iters)

Base.length(lfs::Leafs) = lfs.total_len
Base.eltype(::Type{<:Leafs{<:AbstractTransversal{T,S}}}) where {T,S} = S

function leafs(stabch::StabilizerChain{P,T}) where {P,T}
    transversals = let trs = T[], sch = stabch
        while !istrivial(sch)
            push!(trs, transversal(sch))
            sch = stabilizer(sch)
        end
        trs
    end

    return Leafs(transversals, prod(length, transversals; init = 1))
end

function Base.iterate(lfs::Leafs{<:AbstractTransversal})
    states = last.(iterate.(lfs.iters))

    partial_products = map(1:length(states)-1) do idx
        tr = lfs.iters[idx]
        return tr[first(tr)] # identity, but already allocated
    end

    state = (states = states, partial_products = partial_products)
    res = state.partial_products[end]
    @info state res
    return res, state
end

function Base.iterate(lfs::Leafs{<:AbstractTransversal}, state)
    tr, st = lfs.iters[end], state.states[end]
    next = iterate(tr, st)

    if !isnothing(next)
        pt, st = next
        g = tr[pt]
        state.states[end] = st
        res = g * state.partial_products[end]
        @info state res
        return res, state
    else
        d = depth(lfs)
        while isnothing(next)
            # @debug "resetting $d-th iterator" state.states[d]
            _, state.states[d] = iterate(lfs.iters[d])
            d -= 1
            d == 0 && return nothing
            next = iterate(lfs.iters[d], state.states[d])
        end
        # @debug "advancing $d-th iterator" state.states
        # move forward the next iterator
        tr = lfs.iters[d]
        pt, st = next
        g = tr[pt]
        state.states[d] = st
        # @debug state.states

        begin
            res = d > 1 ? g * state.partial_products[d-1] : g
            state.partial_products[d] = g
        end
        # @show length(state.partial_products) - d
        begin
            # the following elts are the same since tr[first(tr)] is always id!
            # @views fill!(state.partial_products[d:end], res)
            for i in d+1:length(state.partial_products)
                state.partial_products[i] = state.partial_products[i-1]
            end
        end
        @info state res
        return res, state
    end
end

# function Base.iterate(stabch::StabilizerChain, state)
#     next = iterate(last(state.transversals), last(state.states))
#     @inbounds if !isnothing(next)
#         # @debug "next leaf" state.states
#         begin
#             pt, st = next
#             g = state.transversals[end][pt]
#             state.states[end] = st
#             # @debug "after" state.states
#             # we never touch state.elts[end]
#             res = state.elts[end-1] * g
#         end
#         return res, state
#     else
#         # @debug "backtrack" state.states

#         d = length(state.transversals)
#         while isnothing(next)
#             _, state.states[d] = iterate(state.transversals[d])
#             # @debug "resetting $d-th iterator" state.states[d]
#             d -= 1
#             d == 0 && return nothing
#             next = iterate(state.transversals[d], state.states[d])
#         end
#         # @debug "advancing $d-th iterator" state.states
#         # move forward the next iterator
#         pt, st = next
#         g = state.transversals[d][pt]
#         state.states[d] = st
#         # @debug state.states

#         @time state.elts[d] = d > 1 ? state.elts[d-1] * g : g
#         @show length(state.transversals) - d
#         @time begin
#             # the following elts are the same since tr[first(tr)] is always id!
#             # @views fill!(state.elts[d+1:end], state.elts[d])
#             for i in d+1:length(state.transversals)-1
#                 state.elts[i] = state.elts[i-1]
#             end
#         end

#         return state.elts[end], state
#     end
# end

# function Base.iterate(stabch::StabilizerChain{P,T}) where {P,T}
#     # initialize here
#     istrivial(stabch) && return nothing

#     transversals = let trs = T[], sch = stabch
#         while !istrivial(sch)
#             push!(trs, transversal(sch))
#             sch = stabilizer(sch)
#         end
#         trs
#     end

#     states = last.(iterate.(transversals))
#     elts = [tr[first(tr)] for tr in transversals]

#     state = (transversals = transversals, states = states, elts = elts)

#     return last(elts), state
# end
