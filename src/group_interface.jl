# Group Interface

Base.one(G::PermGroup) = Permutation(Perm(degree(G)), G)
GroupsCore.order(::Type{T}, G::AbstractPermutationGroup) where {T} =
    order(T, StabilizerChain(G))
GroupsCore.gens(G::PermGroup) = G.(G.gens)

# TODO:
# Base.rand

### iteration protocol for PermGroups

Base.eltype(::Type{GT}) where {I,GT<:PermGroup{I}} = Permutation{I,GT}
Base.IteratorSize(::Type{<:AbstractPermutationGroup}) = Base.HasLength()

function Base.iterate(G::PermGroup)
    return one(G), (deepcopy(base(G)), 1, order(G))
end

function Base.iterate(G::PermGroup, state)
    base_im, count, ord_G = state
    count == ord_G && return nothing

    basis_im = next!(base_im, transversals(G))
    g = perm_by_baseimages(G, base_im)

    return (g, (base_im, count + 1, ord_G))
end

# GroupElement Interface
Base.parent(g::Permutation) = g.parent
GroupsCore.parent_type(::Type{Permutation{I,GT}}) where {I,GT} = GT

Base.:(==)(g::Permutation, h::Permutation) = parent(g) === parent(h) && g.perm == h.perm

Base.deepcopy_internal(g::Permutation, stackdict::IdDict) =
    perm(deepcopy_internal(g.perm, stackdict), parent(g))

Base.inv(g::Permutation) = parent(g)(inv(g.perm))

function Base.:(*)(g::Permutation, h::Permutation)
    parent(g) === parent(h) ||
        error("Cannot multiply elements from different permutation groups")

    G = parent(g)
    return G(g.perm * h.perm)
end

# IO

function Base.show(io::IO, G::PermGroup)
    init = isdefined(G, :stabchain) ? " of order $(order(StabilizerChain(G)))" : ""
    ngen = length(gens(G))

    print(io, "Permutation group on ", ngen, " generator", ngen > 1 ? "s" : "", init)
end

function Base.show(io::IO, ::MIME"text/plain", G::PermGroup)
    init = isdefined(G, :stabchain) ? " of order $(order(StabilizerChain(G)))" : ""
    ngen = length(gens(G))

    println(
        io,
        "Permutation group on ",
        ngen,
        " generator",
        ngen > 1 ? "s" : "",
        init,
        " generated by",
    )
    Base.print_array(io, gens(G))
end

Base.show(io::IO, g::Permutation) = show(io, perm(g))

### Performance optimizations

Base.similar(p::Permutation{T}, ::Type{S} = T) where {T,S} =
    Permutation(similar(perm(p), T), parent(p))
Base.isone(p::AbstractPerm) = iszero(nfixedpoints(p))
Base.:(^)(p::Permutation, n::Integer) = parent(p)(p.perm^n)
GroupsCore.order(::Type{T}, p::Permutation) where {T} = order(T, p.perm)
Base.hash(p::Permutation, h::UInt) = hash(typeof(p), hash(p.perm, hash(parent(p), h)))

# Mutable API

function GroupsCore.one!(g::AbstractPerm)
    for i in eachindex(g)
        g[i] = i
    end
    return g
end

Base.@propagate_inbounds function GroupsCore.mul!(
    out::AbstractPerm,
    g::AbstractPerm,
    h::AbstractPerm,
)
    out = (out === h ? similar(out) : out)
    @boundscheck @assert degree(out) >= max(degree(g), degree(h))

    @inbounds for i in eachindex(out)
        out[i] = (i^g)^h #h[g[i]]
    end

    return out
end

#### end of Group interface

# accessors

perm(g::Permutation) = g.perm

gens_raw(G::PermGroup) = G.gens

# AbstractPerm Interface??

Base.setindex!(g::Permutation, v::Integer, n::Integer) = g.perm[n] = v

@doc doc"""
	degree(G::PermGroup)
Return the degree of `G`, i.e. the length of the storage of permutations in `G`.
"""
degree(G::PermGroup) = return G.deg
degree(p::Permutation) = degree(parent(p))
degree(p::Perm{I}) where {I} = I(length(p.d))
